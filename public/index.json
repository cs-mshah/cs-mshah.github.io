[{"categories":[],"content":"This post outlines the approach I used for NCVPRIPG23's challenge on writer verification","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/"},{"categories":[],"content":" The ChallengeThe statement is simple. Given two images of handwritten texts, predict whether they’ve been written by the same person or not. This challenge was a part of the 8th National Conference on Computer Vision, Pattern Recognition, Image Processing and Graphics. You can go and have a look at the above link for the details of the challenge and dataset (as of writing the dataset isn’t public). Writer Verification Challenge You can also have a look at the project repository along with this blog. TL;DR Used a ResNet50 with DINO pretrained weights. Trained the network using triplet loss. Final test AUC is 0.97588 in just 10 epochs. ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:1:0","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#the-challenge"},{"categories":[],"content":" Exploratory Data Analysis (EDA)For exploring computer vision datasets I use Voxel51, which is one of the coolest tools to qualitatively view your dataset. You can go ahead and read their extensively detailed documentation along with tutorials to get an idea of the power it has. Using it for this challenge was as simple as doing pip install fiftyone import fiftyone as fo def fiftyone_vis(dataset_dir: str): # Create the dataset dataset = fo.Dataset.from_dir( dataset_dir=dataset_dir, dataset_type=fo.types.ImageClassificationDirectoryTree, name=name, ) session = fo.launch_app(dataset) session.wait() The above code is generic enough to view any dataset organized in the standard :ImageFolder structure of PyTorch. The session.wait() is important to keep the server running. Here is the amazing visualization which we get: voxel51 We can clearly see the class labels and several other filters/tools in the dashboard. The images are of varying sizes and with only a few images per writer class. The written text contains English alphabets, special symbols (punctuations, superscript, digits, special chars), lines, paragraphs, 2 text boxes in one image, printed text, strikes, written text going outside the black boundary box, text written at angles and a few blank texts. Although there is a lot of scope for preprocessing, I started without it to find out the initial results, which turned out to be pretty decent. ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:2:0","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#exploratory-data-analysis-eda"},{"categories":[],"content":" Model ArchitectureDue to a large number of writer classes and only a few images per class, the problem can be modelled into a metric learning task, where the goal is to learn a similarity function between pairs of images. With this similarity metric, we would finally be able to predict whether two texts come from the same writer (by setting an appropriate threshold). Evaluation Metric As the problem is that of binary classification, the metric for the challenge is the AUC score. The overall architecture consists of two things The encoder part (backbone) to encode images. The loss function to train the model on. architecture ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:3:0","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#model-architecture"},{"categories":[],"content":" The Image EncoderThe encoder is a simple ResNet50 with an output dimension of 64 (instead of the default 1000). For getting a good backbone, I thought of using DINO pretrained weights on ImageNet. Several papers have shown this backbone to be strong in downstream metric learning tasks. I just started with a ResNet50, but a ViT could’ve been tried too, along with the more recent DINOv2 weights. I used a generic classifier from the Transfer Learning Library, which can be configured to have different backbones, bottlenecks and heads. Another benefit is that the learning rates of different layers can also be configured. ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:3:1","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#the-image-encoder"},{"categories":[],"content":" The Triplet LossThe triplet loss seemed to be one of the ideal choices to train the network on. The motivation comes from the following: Triplet Loss - Advanced Intro The loss is defined by, Loss Function $$ L(a,p,n) = max\\{d(a_i, p_i)-d(a_i, n_i) + margin, 0\\} $$ Where, $a - \\textnormal{denotes the anchor}$ $p - \\textnormal{denotes the positive (image from the same writer class as anchor)}$ $n - \\textnormal{denotes the negative (image from a different writer class as anchor)}$ $d - \\textnormal{distance metric (CosineSimilarty in this case)}$ $\\textnormal{margin }-\\textnormal{ distance between (ap) and (an) pairs}$ pytorch-metric-learning For implementing losses, miners and samplers, I used the state of the art pytorch-metric-learning library. Triplets are mined by a $\\verb|TripletMarginMiner|$ function depending on specific conditions. I kept the margin as 0.2 (could’ve been a hyperparameter) in all experiments. ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:3:2","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#the-triplet-loss"},{"categories":[],"content":" TrainingA learning rate of 0.01 was used for the head (fc layer), 0.001 was used for the backbone, along with adam as the optimizer and an exponentially decaying $lr$ scheduler. The $lr$ decays every epoch according to, $$lr = lr_0(1 + 0.001lr)^{-0.75}$$ The choice of hyperparameters in this case is purely based on some past experience with using the Transfer-Learning-Library. MPerClassSampler Instead of the standard RandomSampler for sampling images of a batch, I made use of an :MPerClassSampler from the pytorch-metric-learning library, which samples $M=4$ images of every class in a batch. The benefit of doing this is a much faster convergence due to the production of a large number of triplets in a batch, making it more useful than random sampling. weights and biases logs The entire training logs of all experiments can be found at: wandb Training plots of the best model ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:3:3","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#training"},{"categories":[],"content":" Results and ConclusionsHere is an overview of some of the ablations that were conducted. AUC (Val) Batch Size Miner Sampler Epochs 0.7217 32 semihard - 20 0.9642 128 semihard - 80 0.9782 128 all - 80 0.9775 128 all MPerClass 10 It is clear from the table that one needs a larger batch size (which is obvious in metric learning tasks). all mining strategy generates more triplets, and this strategy works slightly better than the other options. hard mining resulted in the loss to collapse and ultimately halt training, due to a decrease in the triplets mined after a few epochs. An MPerClassSampler greatly improves training time. The AUC of the best model on the val set turned out to be 0.9775 and that of the test set turned out to be 0.97588 Overall, it was an amazing experience for me to win my first challenge. ","date":"23-07-2023","objectID":"/ncvpripg23_writer_verification/:4:0","series":[],"tags":["CV"],"title":"Winning the NCVPRIPG23 Challenge on Writer Verification","uri":"/ncvpripg23_writer_verification/#results-and-conclusions"},{"categories":[],"content":"This contains my notes from the CS161: Computer Security course from UC Berkeley.","date":"24-05-2023","objectID":"/cs161_computer_security_notes/","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/"},{"categories":[],"content":" What this post is aboutCS161 | Computer Security is a good introductory course on computer security. It covers basics of Memory Safety, Cryptography, Web Security and Network Security. Their textbook was one of the reference books for an introductory computer security course that I had taken in college under Dr. Ravi Mittal. I just thought of posting some notes that I had made from the textbook while reading from some of the sections. I think these might be useful for people who want to get the key points at a glance, although I would highly recommend reading the textbook, which in itself is crisp. You can directly jump to any section from the table of contents. Here you go! ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:1:0","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#what-this-post-is-about"},{"categories":[],"content":" Cryptography","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:0","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#cryptography"},{"categories":[],"content":" Basics Kerckhoff’s Principle is a security principle which states that cryptosystems should remain secure even when the attacker knows all the internal details of the system, except the key. Shannon’s maxim is a security principle wherein the enemy knows the system, meaning that you should assume that the attacker knows every detail about the system you are working with. (Don’t rely on security through obscurity) Actors Alice and Bob: The main characters trying to send messages to each other over an insecure communication channel. Carol and Dave can also join the party later Eve: An eavesdropper who can read any data sent over the channel (an honest-but-curious attacker). Mallory: A manipulator who can read and modify any data sent over the channel (a malicious attacker). CIA model Confidentiality is a goal of cryptography wherein the adversary cannot read our messages. Essentially, the ciphertext should not give the attacker any additional information about the plaintext. experiment: Alice has encrypted and sent one of two messages, either $M_0$ or $M_1$, and the attacker, Eve, has no idea which was sent. Eve tries to guess which was sent by looking at the ciphertext. If the encryption scheme is confidential, then Eve’s probability of guessing which message was sent should be $1/2$. This experiment can be applied to different threat models. Integrity is a goal of cryptography wherein the adversary cannot change any messages without being detected. Authenticity is a goal of cryptography wherein one can prove that a message came from the person who claims to have written it. Symmetric and Asymmetric-Key Cryptography property Symmetric-key Asymmetric-key Confidentiality Block ciphers with chaining modes (e.g., AES-CBC) Public-key encryption(e.g., El Gamal, RSA encryption) Integrity and authentication MACs (e.g., AES-CBC-MAC) Digital signatures (e.g., RSA signatures). Alice computes a digital signature of her message using her private key, and appends the signature to her message. When Bob receives the message and its signature, he will be able to use Alice’s public key Scheme overview Alice uses her secret key to encrypt a message, and Bob uses the same secret key to decrypt the message Alice can encrypt her message under Bob’s public key and Bob will be able to decrypt using his private key. Threat models column 2: can eve trick Alice highlight - focus of this course. encryption algorithms provide security against chosen-plaintext/ciphertext attacks, both because those attacks are practical in some settings, and because it is in fact feasible to provide good security even against this very powerful attack model. replay-attack: eve can send Bob a repeated encrypted message from Alice. IND-CPA secure (indistinguishability under chosen plaintext attack): even if Eve can trick Alice into encrypting some messages, she still cannot distinguish whether Alice sent $M_0$ or $M_1$ with probability greater than half. if a scheme leaks the plaintext length, it can still be considered IND-CPA secure. (because not leaking length information is impractical) Eve is limited to a practical number of encryption requests. any algorithm Eve uses during the game must run in $O(n^k)$ time, for some constant $k$. Eve only wins if she has a non-negligible advantage. Only non-deterministic schemes are IND-CPA secure as nothing is preventing Eve from asking Alice again. One-time pad Key generation: Alice and Bob pick a shared random key $K$. Encryption $C=M\\oplus{K}$ Decryption $M=C\\oplus{K}$ IND-CPA secure The shared key cannot be reused to transmit another message M′, making this infeasible for practical purposes as new keys need to be generated every time. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:1","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#basics"},{"categories":[],"content":" Block Ciphers A block cipher transforms a fixed-length, $n$-bit input into a fixed-length $n$-bit output. Encryption function $E:\\{0,1\\}^k \\times \\{0,1\\}^n \\rightarrow \\{0,1\\}^n$ is a permutation of the $n$-bit input string, given some fixed $k$-bit key. This function is invertible and bijective as it should allow decryption. Most common: AES (Advanced Encryption Standard). ($n$ = 128, $k$ = 128). AES is computationally indistinguishable from random. (no proof. but believed to be) Block ciphers alone are not IND-CPA secure as they are deterministic. To solve this randomization is needed. Mode Encryption Decryption Parallelizable IND-CPA secure ECB (electronic code book) $C_i=E_K(M_i)$ $M_i=D_K(C_i)$ Both Encryption and Decrytion No CBC (cipher block chaining) $\\begin{cases} C_0 = IV \\cr C_i = E_K(P_i \\oplus C_{i-1}) \\end{cases}$ $P_i = D_K(C_i) \\oplus C_{i-1}$ Only Decryption Yes CFB (ciphertext feedback) $\\begin{cases} C_0 = IV \\cr C_i = E_K(C_{i-1}) \\oplus P_i \\end{cases}$ $P_i = E_K(C_{i-1}) \\oplus C_i$ Only Decryption Yes OFB (output feedback) $\\begin{cases} Z_0 = IV \\cr Z_i = E_K(Z_{i-1}) \\cr C_i = M_i \\oplus Z_i \\end{cases}$ $P_i = C_i \\oplus Z_i$ Only Decryption Yes CTR (counter) $C_i = E_K(IV + i) \\oplus M_i$ $M_i = E_K(IV + i) \\oplus C_i$ Both Encryption and Decryption Yes. $IV$ loss catastrophic ECB(electronic code book) mode plaintext $M$ is simply broken into $n$-bit blocks $M_1 \\dots M_l$, Encryption: $C_i=E_K(M_i)$ Decryption $M_i=D_K(C_i)$ flawed as it leaks information. (if $M_i=M_j$ then $C_i=C_j$) CBC(cipher block chaining) mode $IV$ : random $n$-bit string called initialization vector, new for every message (to be used only once), public. (also called nonce - number used once) Encryption: $\\begin{cases} C_0 = IV \\cr C_i = E_K(P_i \\oplus C_{i-1}) \\end{cases}$ (Cannot be parallelized) Decryption: $P_i = D_K(C_i) \\oplus C_{i-1}$ (Can be parallelized) strong security guarantees CFB Mode (Ciphertext Feedback Mode) Encryption: $\\begin{cases} C_0 = IV \\cr C_i = E_K(C_{i-1}) \\oplus P_i \\end{cases}$ Decryption: $P_i = E_K(C_{i-1}) \\oplus C_i$ OFB Mode (Output Feedback Mode) Encryption: $\\begin{cases} Z_0 = IV \\cr Z_i = E_K(Z_{i-1}) \\cr C_i = M_i \\oplus Z_i \\end{cases}$ Decryption: $P_i = C_i \\oplus Z_i$ Counter (CTR) Mode Encryption: $C_i = E_K(IV + i) \\oplus M_i$ Decryption: $M_i = E_K(IV + i) \\oplus C_i$ Note that all the above schemes can be tampered by simply swapping different ciphertext blocks, thus providing Confidentiality but not Integrity and Authenticity. Padding Used when message isn’t multiple of block size. Padding scheme PKCS#7: pad the message by the number of padding bytes used. Used in CBC (cipher block chaining) mode but not in CTR (counter) mode. See the decryption function to decide. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:2","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#block-ciphers"},{"categories":[],"content":" Cryotographic Hashes One Way: $y=H(x)$. Not possible to find $x$ s.t $H(x)=y$ for a given $y$. Second preimage resistant: infeasible to find another input $x’$ such that $x’ \\neq x$ but $H(x)=H(x’)$. Collision resistant: infeasible to find any pair of messages $x,x’$ such that $x \\neq x’$ but $H(x)=H(x’)$. (practically infeasible) Example use case: If publicised hash is authentic, then we can compare the publicised hash with the downloaded software/file’s hash to check if it hasn’t been tampered with. Algorithms MD5, SHA-1: broken SHA-2 (vulnerable to length extension attack), SHA-3: in use selection: relate output length to corresponding symmetric key algorithm. For AES-128, use SHA-256 or SHA-384, making cracking equally difficult ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:3","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#cryotographic-hashes"},{"categories":[],"content":" Message Authentication Codes (MACs) The MAC on a message $M$ is a value $F(K,M)$ computed from $K$ and $M$; the value $F(K,M)$ is called the tag for $M$ or the MAC of $M$. Typically, we might use a 128-bit key $K$ and 128-bit tags. While sending a message send $\\langle M,T \\rangle$. To check integrity and authenticity, compute the MAC of the message part and compare with the Tag. Deterministic as it is used for comparing. Does not guarantee confidentiality. Only Authenticity and Integrity No eve should be able to generate valid MAC for unseen messages. MACs provide security against chosen-plaintext/ciphertext attacks. AES-EMAC $K=\\langle K_1, K_2 \\rangle$ $M = P_1 \\Vert P_2 \\Vert … \\Vert P_n$ $S_0=0$, $S_i=AES_{K_1}(S*i-1 \\oplus P_i)$ $T=AES_{K_2}(S_n)$ provably secure assuming AES is secure. HMAC (Hash Message Authentication Code) when using with a block cipher, choose an HMAC whose output is $2 \\times key$ length used for the associated block cipher. output of HMAC is the same number of bits as the underlying hash function $\\text{NMAC}(K_1, K_2, M) = H(K_1 \\Vert H(K_2 \\Vert M))$ HMAC (uses only 1 key) is a more specific version of NMAC Authenticated encryption encrypt-then-MAC $\\langle \\mathsf{Enc}_{K_1}(M), \\mathsf{MAC}_{K_2}(\\mathsf{Enc}_{K_1}(M))\\rangle$ better approach. MAC-then-encrypt approach $\\mathsf{Enc}_{K_1}(M \\Vert \\mathsf{MAC}_{K_2}(M))$ only detect if the message is tampered after we decrypt it. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:4","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#message-authentication-codes-macs"},{"categories":[],"content":" Pseudorandom Number Generators Seed(entropy): Take in some initial truly random entropy and initialize the pRNGs internal state. Reseed(entropy): Take in some additional truly random entropy, updating the pRNGs internal state as needed. Generate(n): Generate $n$ pseudorandom bits, updating the internal state as needed. Some pRNGs also support adding additional entropy directly during this step. rollback resistance: previously-generated output of the pRNG should still be computationally indistinguishable from random, even if the attacker knows the current internal state of the pRNG. HMAC-DRBG computes HMAC on the previous block of pRNG output. repeats. internal state: $K$ and $V$ (message part of HMAC). update after generation of $n$ bits. Additional true randomness can also be provided. Stream-Cipher encrypt a stream of bytes coming (Ex. movie) Use one time pad for encryption and decryption of every bit. bits generated using pRNG Secret key is used to seed the pRNG use an additional $IV$ to seed. Encryption: $Enc(K, M) = \\langle IV, PRNG(K, IV) \\oplus M \\rangle$ Decryption: $Dec(K, IV, C_2) = PRNG(K, IV) \\oplus C_2$ Use of counter in stream cipher: ability to encrypt or decrypt an arbitrary point in the message without starting from the beginning ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:5","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#pseudorandom-number-generators"},{"categories":[],"content":" Diffie-Hellman Key Exchange Remember the paint exchange analogy. One public paint colour is known. Alice and Bob exchange public paint mixed with their own secret colours and then add their own colour to the received mix to generate the common secret key. One way function $f$ s.t given $x$, it is easy to compute $f(x)$, but given $y$, it is practically impossible to find a value $x$ s.t $f(x)=y$ Ex. $f(x) = g^x \\bmod p$. ($p$ is a large prime and $1\u003cg\u003cp-1$) discrete logarithm problem: computationally hard to solve $g$, $p$ are fixed and public $A = g^a \\bmod p$ $B = g^b \\bmod p$. ($a$, $b$ $\\in {0,1,\\dots,p-2}$) $S = B^a = A^b = g^{ab} = g^{ba} \\bmod p$. $S$ is the shared secret. Elliptic curve Diffie-Hellman: smaller keys with same security Protocol only resistant against Eve but not Mallory. Happens due to lack of integrity and authenticity. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:6","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#diffie-hellman-key-exchange"},{"categories":[],"content":" Public Key Encryption Public-key cryptography provides a nice way to help with the key management problem. Alice can pick a secret key $K$ for some symmetric-key cryptosystem, then encrypt $K$ under Bob’s public key and send Bob the resulting ciphertext. Bob can decrypt using his private key and recover $K$. Then Alice and Bob can communicate using a symmetric-key cryptosystem, with $K$ as their shared key, from there on. trapdoor one-way function: same as a one-way function, but given $y$ and a special backdoor $K$, it is easy to find an $x$ s.t $f(x)=y$. given a private key $PK$ and a ciphertext $y$, it is easy for find $x=f^{-1}(y)$. El Gamal encryption: System parameters: a 2048-bit prime $p$, and a value $g$ in the range $2 \\ \\dots p − 2$. Both are arbitrary, fixed, and public. Key generation: Bob picks $b$ in the range $0 \\dots p − 2$ randomly, and computes $B = g^b \\bmod p$. His public key is $B$ and his private key is $b$. Encryption: $E_B(m) = (g^r \\bmod p, m \\times B^r \\bmod p)$ where $r$ (Alice’s private key) is chosen randomly from $0 \\dots p − 2$, let $R = g^r \\bmod p$. Decryption: $D_b(R,S) = R^{−b} \\times S \\bmod p$. RSA encryption: Key generation: $p, q$ random 2 large primes. $N=pq$ let $e$ (usually 3, 17, 65, 537) be such that $gcd(e, (p - 1)(q - 1)) = 1$ Public Key: $(N, e)$ Private Key: $d = e^{-1} \\bmod (p-1)(q-1)$ Enc(e, N, M): $C = M^e \\bmod N$ Dec(d, C): $C^d \\bmod N$. RSA isn’t IND-CPA secure (because deterministic). to counter this, OAEP (Optimal Asymmetric Encryption Padding) is used. RSA uses two variables during encryption while El Gamal uses three variables Public key cryptography relies on the fact that the published public key really belongs to the person it is supposed to. Is the public key integrity maintained? Session keys: because public key cryptography is computationally expensive, we use it to distribute session keys. These keys are symmetric keys used for various purposes - encrypting messages and in MACs. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:7","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#public-key-encryption"},{"categories":[],"content":" Digital Signatures Needed for non repudiation In case of symmetric keys, we cannot prove who generated the message. Asymmetric algorithms On its own doesn’t provide confidentiality Use private key while signing Key generation: There is a randomized algorithm $KeyGen$ that outputs a matching public key and private key: $(PK,SK) = KeyGen()$ . Each invocation of $KeyGen$ produces a new keypair. Signing: There is a signing algorithm Sign: $S = Sign(SK,M)$ is the signature on the message $M$ (with private key $SK$). Verification: There is a verification algorithm $Verify$, where $Verify(PK,M,S)$ returns true if $S$ is a valid signature on $M$ (with public key $PK$) or false if not. RSA Signatures: $H(M) = F_U(S)$. $S$ is the signature, $H$ is the hash function. $F$ is a trapdoor one-way function, $U$ - public key. The signer computes $S = F^{-1}(H(M))$ as he has the private key $K$ Because $H$ is one way and $F$’s trapdoor is not known to the attacker, the message cannot be decrypted by an attacker. Hash allows signing large messages. digital envelop message + signature is visible. used for confidentiality. uses symmetric keys too. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:8","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#digital-signatures"},{"categories":[],"content":" Digital certificates how do we know that the public key is authentic as claimed by the person? MITM attack on public keys Digital certificates are a way to represent an alleged association between a person’s name and their public key, as attested by some certifying party. The certifying party signs a message with the name and public key of the person with its own private key. For Alice to communicate with Bob, she needs to trust the certifying authority and have its trusted correct public key to decrypt the message and obtain Bob’s public key. The public key of the trusted CA can be hardcoded in applications that need to use cryptography. Web browsers come configured with a list of many trusted CAs. certificate chain: a sequence of certificates, each of which authenticates the public key of the party who has signed the next certificate in the chain. Revocation: CA can issue certificates with validity periods and additionally list invalid certificates through revocation lists. Risk: DoS attack on the revocation list servers. roughly 150 root CAs ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:9","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#digital-certificates"},{"categories":[],"content":" Bitcoin The goal of Bitcoin is to replicate these basic properties of a functioning currency system, but without any centralized party. Instead of relying on a trusted entity, Bitcoin uses cryptography to enforce the basic properties of currency. Identity: Public key of a user. Messages: $PK_A$ sends $n$ units of currency to $PK_B$ anyone can confirm this Balances Trusted ledger A ledger is a written record that everybody can view append only, immutable distributed Hash chains if you get the hash of the latest block from a trusted source, then you can verify that all of the previous history is correct Block 1 Block 2 Block 3 Block 4 Block 5 $m_1$ $m_2, H(\\text{Block}_1)$ $m_3, H(\\text{Block}_2)$ $m_4, H(\\text{Block}_3)$ $m_5, H(\\text{Block}_4)$ consensus every participant in the network stores the entire blockchain (and thus all of its history) since we don’t utilize a centralized server. new transaction, is broadcast to everyone, and verified by all. If the transaction is correct, everyone will append it to their local blockchain. assumption - majority of the users are honest (more than half) Consensus via proof of work miners - can only add a block if they have a valid proof of work a computational puzzle that takes the hash of the current block concatenated with a random number. This random number can be incremented so that the hash changes, until the proof of work is solved. Miners then broadcast blocks with their proof of work. All honest miners listen for such blocks, check the blocks for correctness, and accept the longest correct chain. By always accepting the longest blockchain, all the miners are ensured to have the same blockchain view. Sybil attack small number of users counterfeiting multiple peer identities so as to compromise a disproportionate share of the system. Majority is defined by computational power. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:2:10","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#bitcoin"},{"categories":[],"content":" Network Security","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:0","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#network-security"},{"categories":[],"content":" Introduction to Networking A group of local machines forms a local area network (LAN). all machines are connected to all other machines A router is used to connect multiple LANs. wide area network forms the basis of the Internet. Layers Layer 1: Communication of bits Layer 2: Local frame delivery Ethernet: The most common Layer 2 protocol MAC addresses: 6-byte addressing system used by Ethernet Layer 3: Global packet delivery IP: The universal Layer 3 protocol IP addresses: 4-byte (32 bit) addressing system used by IP Layer 4: Transport of data Layer 7: Applications and services (the web) Each layer has its own set of protocols To support protocols, messages are sent with a header Each layer adds its own header to the top of the message provided from the layer directly above. When the message reaches the lowest layer from the top, it now has multiple headers, starting with the header for the lowest layer first. At destination, starting at the lowest layer, the message moves up the protocol stack to higher layers. Each layer removes its header and provides the remaining content to the layer directly above. When the message reaches the highest layer, all headers have been processed, and the recipient sees the regular human-readable text from before. Layer 2 (link layer) uses 48-bit (6-byte) MAC addresses to uniquely identify each machine on the LAN. written as 6 pairs of hex numbers the broadcast address of ff:ff:ff:ff:ff:ff CSMA/CD protocol - carrier sense multiple access collision detection Layer 3 (IP layer) uses 32-bit (4-byte) IP addresses IPv6, uses 128-bit IP addresses, which are written as 8 2-byte hex values separated by colons, such as cafe:f00d:d00d:1401:2414:1248:1281:8712 higher layers (transport layer) assign each process on a machine a unique 16-bit port number web servers HTTP requests - port 80 HTTPS - port 443. Ports below 1024 - “reserved” At the lower layers, we call individual messages packets. Packets are usually limited to a fixed length. The IP (Internet Protocol) at layer 3 only guarantees best-effort delivery, and does not handle any errors. Instead, we rely on higher layers for correctness and security. Adversaries Off-path Adversary: The off-path adversary cannot read or modify any messages over the connection. On-path Adversary: The on-path adversary can read, but not modify messages. In-path Adversary: The in-path (man-in-the-middle) adversary has all the powers of the on-path adversary and can additionally modify and block messages sent by either party. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:1","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#introduction-to-networking"},{"categories":[],"content":" ARP Layer: Link (2) Purpose: Translate IP addresses to MAC addresses Vulnerability: On-path attackers can see requests and send spoofed malicious responses Defense: Switches, arpwatch ARP, the Address Resolution Protocol, translates Layer 3 IP addresses into Layer 2 MAC addresses. ARP replies are always cached three steps: Alice would broadcast to everyone else on the LAN: “What is the MAC address of 1.1.1.1?” Bob responds by sending a message only to Alice: “My IP is 1.1.1.1 and my MAC address is ca:fe:f0:0d:be:ef.” Everyone else does nothing. Alice caches the IP address to MAC address mapping for Bob. ARP Spoofing: no way to verify that the reply in step 2 is actually from Bob Mallory is able to create a spoofed reply and send it to Alice before Bob can send his legitimate reply Defense: arpwatch - tracks the IP address to MAC address pairings across the LAN and makes sure nothing suspicious happens. Switches: VLAN ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:2","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#arp"},{"categories":[],"content":" WPA WPA2-PSK (WiFi Protected Access: Pre-Shared Key) is a protocol that enables secure communications over a WiFi network by encrypting messages with cryptography. Layer: Link (2) Purpose: Communicate securely in a wireless local network Vulnerability: On-path attackers can learn the encryption keys from the handshake and decrypt messages (includes brute-forcing the password if they don’t know it already) Defense: WPA2-Enterprise WPA2-Enterprise gives authorized users a unique username and password the authentication server presents both the client and the access point with a random PMK (Pairwise Master Key) to use instead of the PSK all further communication between the client and the access point is encrypted with the PTK The GTK is used for messages broadcast to the entire network (i.e. sent to the broadcast MAC address, ff:ff:ff:ff:ff:ff). The GTK is the same for everyone on the network, so everyone can encrypt/send and decrypt/receive broadcast messages. In practice, the handshake is optimized into a 4-way handshake, requiring only 4 messages to be exchanged between the client and the access point. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:3","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#wpa"},{"categories":[],"content":" DHCP DHCP (Dynamic Host Configuration Protocol) is responsible for setting up configurations when a computer first joins a local network Steps: Client Discover: The client broadcasts a request for a configuration. Server Offer: Any server able to offer IP addresses responds with some configuration settings. (In practice, usually only one server replies here.) Client Request: The client broadcasts which configuration it has chosen. Server Acknowledge: The chosen server confirms that its configuration has been chosen. Vulnerability: On-path attackers can see requests and send spoofed malicious responses Defense: Accept as a fact of life and rely on higher layers ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:4","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#dhcp"},{"categories":[],"content":" BGP Layer: 3 (inter-network) Purpose: Send messages globally by connecting lots of local networks Vulnerability: Malicious local networks can read messages in intermediate transit and forward them to the wrong place Defense: Accept as a fact of life and rely on higher layers ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:5","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#bgp"},{"categories":[],"content":" TCP and UDP The UDP and TCP header contains 16-bit source and destination port numbers to support communication between processes. The header also contains a checksum (non-cryptographic) to detect corrupted packets. Both protocols are stateless. TCP connection is identified by a 5-tuple of (Client IP Address, Client Port, Server IP Address, Server Port, Protocol=TCP). No Confidentiality or Integrity by itself Sequence number (SYN) Acknowldgement number (ACK) 32 bit 32 bit index of the first byte sent index of the last byte received, plus 1. Ex: in packets from the client to the server, the ACK number is the next unsent byte in the server-to-client stream, and in packets from the server to the client, the ACK number is the next unsent byte in the client-to-server stream reconstruct the message in the correct order after a timeout period, the sender will re-send that packet Each TCP packet can contain both data and an acknowledgment that a previous packet was received To end a connection, one side sends a FIN (a packet with the FIN flag set), and the other side replies with a FIN-ACK. Side that sent the FIN will not send any more data, but can continue accepting data. RST packet unilateral abortion no more packets accepted or sent no acknowledgment Attacks RST injection: abruptly end connection Different network attackers attack differently Off path - needs to guess initial sequence number On path - needs to race an own packet against sender to receiver In path - can block, modify, do anything without racing ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:6","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#tcp-and-udp"},{"categories":[],"content":" TLS TLS (Transport Layer Security) is a protocol that provides an end-to-end encrypted communication channel. (SSL - old version) End-to-end encryption - no person other than sender and receiver can read or modify data. layer 6.5 protocol Uses the underlying TCP. Client sends $R_B$ and a list of encryption protocols it supports. Server responds with $R_S$ and the certificate signed by CA Next is to generate a premature secret (PS) generate random and encrypt with RSA Or, use Diffie Hellman Generating the PS with DHE and ECDHE (elliptic curve DHE) has a substantial advantage over RSA key exchange, because it provides forward secrecy Suppose an attacker records lots of RSA-based TLS communications, and some time in the future manages to steal the server’s private key. Now the attacker can decrypt PS values sent in old connections, which violates the security of those old TLS connections. Use the PS and the random values $R_B$ and $R_S$ to derive a set of four shared symmetric keys: an encryption key $C_B$ and an integrity key $I_B$ for the client, and an encryption key $C_S$ and an integrity key $I_S$ for the server. client and server exchange and verify MACs over all messages sent so far $I_B$ and $I_S$ are known to both the client and server so that they can verify. Security against replay attacks: For a connection: due to randomly generated $R_B$ and $R_S$. For the same connection: counter or timestamp so that an attacker cannot record a TLS message and send it again within the same connection. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:7","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#tls"},{"categories":[],"content":" DNS A DNS query for eecs.berkeley.edu uses UDP 13 root servers Each name server is only responsible for storing information about their children, except for the name servers at the bottom of the tree, which are responsible for storing the actual mappings from domain names to IP addresses. A DNS Recursive Resolver provided by your Internet service provider (ISP), which sends the queries, processes the responses, and maintains an internal cache of records. When performing a lookup, the DNS Stub Resolver on your computer sends a query to the recursive resolver, lets it do all the work, and receives the response. 16 bits 16 bits Identification (used to match requests to responses) Flags (NOERROR, NXDOMAIN) # Questions (=1) # Answer RRs (Resource records) # Authority RRs # Additional RRs Questions (variable # of RRs) Answers (variable # of RRs) Authority (variable # of RRs) Additional info (variable # of RRs) A DNS record key is formally defined as a 3-tuple \u003cName, Class, Type\u003e A DNS record value contains \u003cTTL, Value\u003e A type records map domains to IP addresses (AAAA for IPv6) NS type records map zones to domains number of additional records is always 1 more than the actual number of additional records that appear in the response (extra record corresponds to the OPT pseudosection) $ dig +norecurse eecs.berkeley.edu @128.32.136.3 ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 52788 ;; flags: qr aa; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; QUESTION SECTION: ;eecs.berkeley.edu. IN A ;; ANSWER SECTION: eecs.berkeley.edu. 86400 IN A 23.185.0.1 With bailiwick checking, a name server is only allowed to provide records in its zone. (Ex. a .com NS can’t provide for .edu) The Kaminsky attack relies on querying for nonexistent domains. include malicious additional records in the fake DNS response and make the victim query nonexistent domains. There is no way to completely eliminate the Kaminsky attack in regular DNS, although modern DNS protocols add UDP source port randomization to make it much harder. (This doesn’t stop On path attackers) ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:8","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#dns"},{"categories":[],"content":" DNSSEC DNSSEC is an extension to regular DNS that provides integrity and authentication on all DNS messages sent Issue: What if name server is malicious? Have a trust anchor: The root servers Each name server will sign the public key of all its trusted children name servers, starting from the root The DNSKEY type record encodes a public key. The RRSIG type record is a signature on a set of multiple other records in the message, all of the same type. The DS (Delegated Signer) type record is a hash of the signer’s name and a child’s public key. KSK (Key Signing Key) ZSK (Zone Signing Key) used to sign ZSK used to sign everything else endorsed by the parent resolver verifies by using public ZSK DNSSEC sign records offline–records In case of nonexistent records, name servers pre-compute signatures on ranges of nonexistent domains. NSEC record - no domains exist between domains. NSEC3, NSEC5 - newer versions, uses hash instead of domain names ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:9","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#dnssec"},{"categories":[],"content":" DoS Any attack that is designed to cause a machine or a piece of software to be unavailable and unable to perform its basic functionality is known as a denial of service (DoS) attack. Attackers can generate a unique source IP address for every packet sent, thus preventing the target from successfully identifying and blocking the attacker. Application level exhausting the RAM by having continuous calls to malloc exhausting the processing threads by having continuous calls to fork exhausting the disk I/O operations Prevention: Identification, Isolation, Quotas (proof-of-work : like a CAPTCHA) In a SYN flooding attack send a large number of SYN packets to the server ignore the SYN/ACK replies never send the ACK response mitigation: SYN cookies - Only when the handshake is complete will the server allocate state for the connection after checking the cookie against the secret. Often, attackers carry out DDoS attacks by using botnets, a series of large networks of machines that have been compromised and are controllable remotely. no way to completely eliminate ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:10","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#dos"},{"categories":[],"content":" Firewall Turn off every unnecessary network service Firewalls reduce risk by blocking network outsiders from having unwanted access to all the network services by acting as a choke point between the internet (outsiders) and your internal network. An inbound connection is one that is initiated by external users and attempts to connect to services that are running on internal machines. an outbound connection is one which is initiated by an internal user, and attempts to initiate contact with external services. Security policy: A kind of access control policy Subjects - computers Objects - network services Policy - whether that subject has permission to access that object Two ways Default-allow or blacklist: By default, every network service is permitted unless it has been specifically listed as denied. Default-deny or whitelist: By default, every network service is denied to external users, unless it has been specifically listed as allowed. Much safer bet we can identify each network service with a triplet $(m,r,p)$ $m$ - IP address of a machine $r$ - protocol identifier (i.e. TCP or UDP) $p$ - port number An allow list would include triplets. Ex. (1.2.3.4, TCP, 80) allow tcp ∗:∗ → 1.2.3.4:25 drop ∗ ∗:∗ → ∗:∗ A stateful packet filter maintains state, meaning that it keeps track of all open connections that have been established. Application-layer firewalls restrict traffic according to the content of the data fields. These types of firewalls have certain security advantages since they can enforce more restrictive security policies and can transform data on the fly. Ex. Proxy servers. all traffic goes through them. Firewalls also embody orthogonal security meaning that it can be deployed to protect pre-existing legacy systems much more easily than other security mechanisms that have to be integrated with the rest of the system. ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:11","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#firewall"},{"categories":[],"content":" IP security IP spoofing countermeasures TCP handles it with sequence numbers. Ingress filtering - block outside network packets having inside network address. Egress filtering - block outgoing packets with non matching destination network addresses. ICMP - internet control message protocol helps IP in error reporting simple queries (ping) IPSec layer 3.5 CIA in this layer. modifications in OS connection oriented i.e has state (contrary to IP) IP packet can be changed in a MITM attack as routers have access to the packet. If IP security is handled, then all layers above are secure. use cases - VPNs Send packets by Symmetric key encryption. SA (security association) = SPI + Destination IP + IPSec (ESP pr AH) SPD (security policy database) - used to map outgoing packet to a particular SA ESP Provides source authentication, data integrity and confidentiality transport mode - end to end hosts original IP header is visible tunnel mode (uses gateway) default IPSec mode protects the payload and IP header of original packet authentication is applied to data in ESP header and data in payload. process verify sequence number, verify integrity and decrypt IKE (internet key exchange) for establishing a shared secret for IPSec (SA) bidirectional, contrary to the unidirectional SA ","date":"24-05-2023","objectID":"/cs161_computer_security_notes/:3:12","series":[],"tags":["notes"],"title":"Notes from CS161: Computer Security","uri":"/cs161_computer_security_notes/#ip-security"},{"categories":[],"content":"This post gives a basic setup for CP including setting up CP editor, cf tool, competitive companion, a debugging template and some other resources.","date":"04-12-2021","objectID":"/getting_started_with_cp/","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/"},{"categories":[],"content":" What this post is aboutThis post assumes that you are familiar with Codeforces and competitive programming you know the basics of a particular programming language (C++) This post is more about getting a good setup (according to me) setting up CP Editor, cf-tool and competitive companion some optimisations like pre-compiling headers about setting and using a debug template some resources to practice CP. ","date":"04-12-2021","objectID":"/getting_started_with_cp/:1:0","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#what-this-post-is-about"},{"categories":[],"content":" Selecting the right editorThere are a few good choices for selecting an editor for CP. Here are some: CP editor Sublime Text VS Code I’ll go over the best setup according to me, which is the CP editor with a few other extensions. First, go and download CP editor. If using linux, an AppImage would be fine. Just download the AppImage and give execute permissions. Download cf tool. Extract the executable and add it to a location which is in your PATH. As this is a command line tool, it should be in your PATH. If on a linux machine, you could cd into the folder where you extracted the cf tool and on the terminal type: sudo cp cf /usr/bin/. This would copy the cf tool to /usr/bin/. Note: You can use any other location which is in your $PATH. If using windows, have a look at: Add to the PATH on Windows 10. Now, we need to configure the cf tool, which is where most of the trouble comes. So open the terminal and type cf. If you are unable to see the usage instructions, then it means that your cf isn’t in the PATH. Go above and and do the steps correctly. Now type cf config. Option 0 for login (as we are using it for the first time). After successfully logging in, we will configure our template, so that the tool gets ready for submitting to codeforces. So go ahead and type cf config option 1. Now select the language code. Now enter the absolute path to your template (Look at the template section and come back, If you don’t know what this is). The suffix of template above will be added by default. - leave empty Template's alias (e.g. \"cpp\" \"py\"): - In my case I used cpp Before script - leave empty Script - just add the path to your default template as empty isn’t allowed. After script - leave empty Make it default (y/n)? - y Add competitive companion to your browser. Go to the options of the extension and add 10045 to Custom ports. This is the port which CP editor will listen to for requests. This extension is able to parse the testcases and send them to a port for a large variety of competitive programming websites. With the setup almost done, just open CP editor and check if the Messages section is clean. If there is some error, it means that some tool isn’t configured correctly. If there is an issue with the compiler, then make sure that g++ is in your $PATH. Open the preferences tab and edit your preferences. (preference help can be found on their site too) To test if everything works well, go to any problem on codeforces, and click on the green + icon of your competitive companion extension. Now after opening the CP editor, you should be able to see a new file loaded with the default template and the sample testcases of the problem. Write the code and press compile and run to see the automatic checking of testcases. You can even edit/add testcases and change the type of checker. After you feel that all cases work out, just hit the submit button, to directly submit the problem from within the editor without leaving it!! If you get any error in messages, that means that cf tool hasn’t been configured correctly. Hurray! Hurray !! You have configured your editor with a great setup and can easily submit/check any problem on codeforces ","date":"04-12-2021","objectID":"/getting_started_with_cp/:2:0","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#selecting-the-right-editor"},{"categories":[],"content":" Making your default templateTo speed up the coding, a default template would be nice to have. Here is my default c++ template (as of now. I do make changes to it): #pragma GCC target (\"avx2\") #pragma GCC optimization (\"O3\") #pragma GCC optimization (\"unroll-loops\") #include \"bits/stdc++.h\" /*#include \u003cext/pb_ds/assoc_container.hpp\u003e #include \u003cext/pb_ds/tree_policy.hpp\u003e*/ using namespace std; //using namespace __gnu_pbds; typedef long long ll; typedef long double ld; typedef pair\u003cll,ll\u003e pll; typedef vector\u003cbool\u003e vb; typedef vector\u003cint\u003e vi; typedef vector\u003cll\u003e vll; typedef vector\u003cvi\u003e vvi; typedef vector\u003cvb\u003e vvb; typedef vector\u003cvll\u003e vvll; typedef vector\u003cpll\u003e vpll; typedef vector\u003cstring\u003e vs; typedef unordered_map\u003cll,ll\u003e umll; template\u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e; /*template \u003ctypename num_t\u003e using ordered_set = tree\u003cnum_t, null_type, less\u003cnum_t\u003e, rb_tree_tag, tree_order_statistics_node_update\u003e;*/ // find_by_order(k): iterator to the kth largest(0 indexed). order_of_key(k): no. of items \u003c k #define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME #define FOR3(i,a,b) for(long long i=a;i\u003cb;i++) #define FOR4(i,a,b,step) for(long long i=a;i\u003cb;i=i+step) #define REV3(i,a,b) for(long long i=a;i\u003e=b;i--) #define REV4(i,a,b,step) for(long long i=a;i\u003e=b;i=i-step) #define FOR(...) GET_MACRO(__VA_ARGS__, FOR4, FOR3)(__VA_ARGS__) #define REV(...) GET_MACRO(__VA_ARGS__, REV4, REV3)(__VA_ARGS__) #define F first #define S second #define pb push_back #define ub upper_bound #define lb lower_bound #define all(v) v.begin(),v.end() #define rall(v) v.rbegin(),v.rend() #define tc ll tests;cin\u003e\u003etests;while(tests--) #define io ios_base::sync_with_stdio(false);cin.tie(nullptr); #define coutv(v) for(auto it: (v))cout\u003c\u003cit\u003c\u003c\" \";newl; #define cout2d(v) for(auto it: (v)) {for(auto j:it) cout\u003c\u003cj\u003c\u003c\" \";newl;} #define cinv(v,n) vll (v)(n);FOR(i,0,(n)){cin\u003e\u003ev[i];} #define cinvg(v,n) (v).resize(n);FOR(i,0,(n)){cin\u003e\u003ev[i];} #define cin2d(v,n,m) vvll (v)(n,vll(m,0));FOR(i,0,n){FOR(j,0,m){cin\u003e\u003ev[i][j];}} #define cin2dg(v,n,m) (v).resize(n,vll(m));FOR(i,0,n){FOR(j,0,m){cin\u003e\u003ev[i][j];}} #define pyes(CONDITION) cout \u003c\u003c (CONDITION ? \"YES\" : \"NO\") \u003c\u003c '\\n'; #define newl cout\u003c\u003c\"\\n\" #define MOD 1000000007 #define INF LLONG_MAX/2 #define m1(x) template\u003cclass T, class... U\u003e void x(T\u0026\u0026 a, U\u0026\u0026... b) #define m2(x) (int[]){(x forward\u003cU\u003e(b),0)...} m1(pr) { cout \u003c\u003c forward\u003cT\u003e(a); m2(cout \u003c\u003c \" \" \u003c\u003c); cout \u003c\u003c \"\\n\"; } m1(re) { cin \u003e\u003e forward\u003cT\u003e(a); m2(cin \u003e\u003e); } template \u003cclass ...Args\u003e auto \u0026readd(Args \u0026...args) { return (cin \u003e\u003e ... \u003e\u003e args); } #define re(...) __VA_ARGS__; readd(__VA_ARGS__) const ll dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0}; // const ll dx[8] = {-2,-1,1,2,2,1,-1,-2}, dy[8] = {1,2,2,1,-1,-2,-2,-1}; //knight moves // ************************DEBUG START******************************** #ifndef ONLINE_JUDGE //#define cerr cout #include \"myprettyprint.hpp\" #else #define dbg(...) #endif // ************************DEBUG END********************************** constexpr ll pct(ll x) { return __builtin_popcountll(x); } // # of bits set constexpr ll bits(ll x) {return x == 0LL ? 0LL : 63LL-__builtin_clzll(x); } // floor(log2(x)) constexpr ll p2(ll x) { return 1LL\u003c\u003cx; } constexpr ll msk2(ll x) { return p2(x)-1LL; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); void test() { } int main() { io; ll tests=1; cin\u003e\u003etests; while(tests--) { test(); } return 0; } Lets have a look at how to use the template and some features: typedefs are used to define a new type from existing data types. Have a look at this GFG article for a better understanding. #define defines aliases to certain things. io: ios_base::sync_with_stdio(false);cin.tie(nullptr); for fast input output. GCC pragmas: these are compiler specific, and may optimise certain solutions. There is no guarantee, but it may even work. #ifndef ONLINE_JUDGE //#define cerr cout #include \"myprettyprint.hpp\" #else #define dbg(...) #endif By default the ONLINE_JUDGE constant is defined when submitting code in mo","date":"04-12-2021","objectID":"/getting_started_with_cp/:3:0","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#making-your-default-template"},{"categories":[],"content":" DebuggingThis is a very important part in programming. Everyone faces bugs and we should know how to find them quickly. Here are a few ways: Writing print statements to print the value of variables. Using a debugger and debugging using breakpoints. Both of the above methods have shortcomings.The first one is very slow and while submitting any code, we need to remove the print statement. The second one is not easy for a beginner and requires some other setup and knowledge. So, we need to find something better and smarter. We use our own debugging library. Firstly, one should use good compiler flags to compile the code, so that several things like - Integer Overflow, Array out of bounds and several other errors can be caught and pointed out by the compiler. Here is the compile command which catches several errors and is really useful: g++ -std=c++1z -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -g -fsanitize=undefined (if you want to know more: link) You can add this to your c++ compile command in the preferences of CP editor. Now, coming to the main part. The debugging template: template \u003cclass T1, class T2\u003e ostream \u0026operator\u003c\u003c(ostream \u0026os, const pair\u003cT1, T2\u003e \u0026p) { return os \u003c\u003c '{' \u003c\u003c p.first \u003c\u003c \", \" \u003c\u003c p.second \u003c\u003c '}'; } template \u003cclass T, class = decay_t\u003cdecltype(*begin(declval\u003cT\u003e()))\u003e, class = enable_if_t\u003c!is_same\u003cT, string\u003e::value\u003e\u003e ostream \u0026operator\u003c\u003c(ostream \u0026os, const T \u0026c) { os \u003c\u003c '['; for (auto it = c.begin(); it != c.end(); ++it) os \u003c\u003c \u0026\", \"[2 * (it == c.begin())] \u003c\u003c *it; return os \u003c\u003c ']'; } //support up to 5 args #define _NTH_ARG(_1, _2, _3, _4, _5, _6, N, ...) N #define _FE_0(_CALL, ...) #define _FE_1(_CALL, x) _CALL(x) #define _FE_2(_CALL, x, ...) _CALL(x) _FE_1(_CALL, __VA_ARGS__) #define _FE_3(_CALL, x, ...) _CALL(x) _FE_2(_CALL, __VA_ARGS__) #define _FE_4(_CALL, x, ...) _CALL(x) _FE_3(_CALL, __VA_ARGS__) #define _FE_5(_CALL, x, ...) _CALL(x) _FE_4(_CALL, __VA_ARGS__) #define FOR_EACH_MACRO(MACRO, ...) \\ _NTH_ARG(dummy, ##__VA_ARGS__, _FE_5, _FE_4, _FE_3, _FE_2, _FE_1, _FE_0) \\ (MACRO, ##__VA_ARGS__) //Change output format here #define out(x) #x \" = \" \u003c\u003c x \u003c\u003c \"; \" #define dbg(...) \\ cerr \u003c\u003c \"Line \" \u003c\u003c __LINE__ \u003c\u003c \": \" FOR_EACH_MACRO(out, __VA_ARGS__) \u003c\u003c \"\\n\" This might seem scary to look at, but there’s no need to get scared as we only need to know how to use it. In fact, we can smartly put this in a header myprettyprint.hpp and simply include it using ifndef ONLINE_JUDGE, as I have done in my template. For the include to work, myprettyprint.hpp should be placed in a directory so that it is in the search path when compiling. on linux, you can place it here: /usr/include/c++/9/myprettyprint.hpp. If you don’t know where the compiler looks for header files, then see: gcc Search Path. How to use: ll my_func(ll a, ll b) { return a*b; } void test() { int x=5, y=4; string s=\"Hello\"; vector\u003cint\u003e v={1,2,3,4,5}; set\u003cint\u003e st={34,45}; map\u003cint, vector\u003cint\u003e \u003e m; for(int i=0;i\u003c3;i++) { for(int j=0;j\u003c4;j++) { m[i].push_back(i+j); } } dbg(x, y, s, v, st); dbg(m, my_func(3,7)); } Line 43: x = 5; y = 4; s = Hello; v = [1, 2, 3, 4, 5]; st = [34, 45]; Line 44: m = [{0, [0, 1, 2, 3]}, {1, [1, 2, 3, 4]}, {2, [2, 3, 4, 5]}]; my_func(3,7) = 21; So this debug template is able to print out a variety of stl containers including the ones in pbds (policy based data structures) too. So while submitting the problem, we need not even remove the dbg() statements, as they get automatically converted to empty strings. (else dbg(...)) If you are printing your output to a terminal which supports ANSI based colours, you could even use this debug template: // colout print template \u003cclass T1, class T2\u003e ostream \u0026operator\u003c\u003c(ostream \u0026os, const pair\u003cT1, T2\u003e \u0026p) { return os \u003c\u003c '{' \u003c\u003c p.first \u003c\u003c \", \" \u003c\u003c p.second \u003c\u003c '}'; } template \u003cclass T, class = decltype(begin(declval\u003cT\u003e())), class = enable_if_t\u003c!is_same\u003cT, string\u003e::value\u003e\u003e ostream \u0026operator\u003c\u003c(ostream \u0026os, const T \u0026c) { os \u003c\u003c '['; for (auto it = begin(c); it != end(c); ++it) os \u003c\u003c (it == begin(c) ? \"\" : \", \"","date":"04-12-2021","objectID":"/getting_started_with_cp/:4:0","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#debugging"},{"categories":[],"content":" Precompiling header filesThis section is mostly for those who face long compile times (\u003e2s-3s). One way to reduce compile time is to precompile the header files using the same compile command that you use to compile your code. navigate to the header file bits/stdc++.h on your terminal (/usr/include/x86_64-linux-gnu/c++/9/bits on ubuntu) and type: sudo g++ -std=c++1z -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -g -fsanitize=undefined stdc++.h You could also copy the above file and place it in the directory having your code. Precompiling here will also generate the .gch file. All you need to change in your code is #include \u003cbits/stdc++.h\u003e to #include \"\u003cbits/stdc++.h\u003e\". This will tell the compiler to search for a local header in the bits subdirectory and name stdc++.h first, and then the default search path. When the compiler finds a .gch file, it uses it instead of the .h file. CP_files │ │ probA.cpp │ └───bits │ stdc++.h | stdc++.gch This should reduce your compile time a little. ","date":"04-12-2021","objectID":"/getting_started_with_cp/:5:0","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#precompiling-header-files"},{"categories":[],"content":" ResourcesPRACTICE PRACTICE PRACTICE. The only thing that can help you get better at CP. Here are some resources which are best for practice and learning. Note that these are just some good ones according to me. There are several others which you can easily find, but the point to remember is to focus on actual practice and not to get overwhelmed by the mammoth content out there. ","date":"04-12-2021","objectID":"/getting_started_with_cp/:6:0","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#resources"},{"categories":[],"content":" Practice and Learning USACO guide : This is one of the finest resources written by topcoders. It has everything. Right from guidance to practice problems. hackerearth : this site contains good articles and practice problems. cp-algorithms : one of the best references for theory and implementation of a large variety of algorithms in c++. codeforces : One of the best sites to practice and improve. It contains severals problems and contests. Just sort the problems based on a particular rating (typically +200-300 of your current) and start practicing. You can also host mashups and practice. codechef : This site has good problems and contest too. The DSA learning series is also amazing to learn a particular topic. atcoder : This site hosts good quality problems. the ABC beginner contests are resourceful to a beginner. a2oj : This has currently been discontinued, but with this extension, you can pick a ladder and start solving. Blogs Catalog - Codeforces The Ultimate Topic List (with Resources, Problems and Templates)s ","date":"04-12-2021","objectID":"/getting_started_with_cp/:6:1","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#practice-and-learning"},{"categories":[],"content":" Youtube channels Code N Code: A good channel which explains several topics. Kartik Arora : He is a CM himself and explains several topics. Priyansh Agarwal : He is a CM himself and explains several topics and does screencasts. Utkarsh Gupta: A GM himself, has explained and done several screen casts. Colin Galen: A GM who regularly does screen casts of contests. Neal Wu: A legend’s channel! ","date":"04-12-2021","objectID":"/getting_started_with_cp/:6:2","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#youtube-channels"},{"categories":[],"content":" Browser extensions codeforces customizer: An extension made by me!! Check the blog to see what it does. Use the all submissions tab to see others’ submissions and improve! (also do not forget to upvote the blog and rate a 5 star 🌟 on the chrome web store 😁) keep problems: use this to mark favourite problems/add notes/export etc. ","date":"04-12-2021","objectID":"/getting_started_with_cp/:6:3","series":[],"tags":["CP","Beginner"],"title":"Getting started with competitive programming","uri":"/getting_started_with_cp/#browser-extensions"},{"categories":null,"content":" Me in the Sissu Valley I have graduated with a bachelors degree in Computer Science and Engineering from IIT Mandi. I am currently working as a software development engineer at Cashfree Payments. I’ve spent a summer (2022) interning at Microsoft India Development Center | MSIDC working with the STCI (Search Technology Centre India) team. I am interested in working on challenging problems in computer vision and deep learning. I am currently exploring NeRFs and Gaussian splatting. I have a good experience with PyTorch, PyTorch Lightning and experimentation with wandb. I am open to collaborate on research projects related to computer vision. In my free time, I like to fiddle with Obsidian and keep perfecting workflows to do several things (yeah I know it might decrease productivity at times, but it does pay off). Some other amazing communities that I love exploring and contributing include Cohere For AI, PyTorch, PyTorch Lightning and weights and biases. This blog is primarily about my learnings, experiences and thoughts. I feel that writing helps me to solidify different concepts and share some insights with others. ","date":"01-01-0001","objectID":"/about/:0:0","series":null,"tags":null,"title":"","uri":"/about/#"}]